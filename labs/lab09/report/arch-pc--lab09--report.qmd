---
## Author
author:
  name: Кебеде Берекет Дагне, НПИбд-01-25
  email: 1032255864@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Архитектура ЭВМ"
subtitle: "Лабораторная работа №9. Понятие подпрограммы. Отладчик GDB."
license: "CC BY"

format:
  pdf:
    documentclass: article
    mainfont: "DejaVu Serif"
    lang: ru
    geometry: [left=2cm, right=2cm, top=2cm, bottom=2cm]
  docx: default
toc: true
number-sections: true
---

# Цель работы

Приобретение навыков написания программ с использованием подпрограмм. Знакомство с методами отладки при помощи GDB и его основными возможностями.

# Задание

1.  Реализовать программу вычисления арифметического выражения с использованием подпрограммы.
2.  Модифицировать программу, добавив вложенную подпрограмму.
3.  Изучить основные команды отладчика GDB: установка точек останова, пошаговое выполнение, просмотр и изменение регистров и памяти.
4.  Исследовать расположение аргументов командной строки в стеке с помощью GDB.
5.  Выполнить самостоятельные задания:
    -   Преобразовать программу из лабораторной работы №8, реализовав вычисление значения функции как подпрограмму.
    -   С помощью отладчика GDB найти и исправить ошибку в программе вычисления выражения.

# Теоретическое введение

## Понятие об отладке

Отладка — это процесс поиска и исправления ошибок в программе. В общем случае его можно разделить на четыре этапа:

-   обнаружение ошибки;
-   поиск её местонахождения;
-   определение причины ошибки;
-   исправление ошибки.

Можно выделить следующие типы ошибок:

-   синтаксические ошибки — обнаруживаются во время трансляции исходного кода и вызваны нарушением ожидаемой формы или структуры языка;
-   семантические ошибки — являются логическими и приводят к тому, что программа запускается, отрабатывает, но не даёт желаемого результата;
-   ошибки в процессе выполнения — не обнаруживаются при трансляции и вызывают прерывание выполнения программы (например, это ошибки, связанные с переполнением или делением на ноль).

## Основные возможности отладчика GDB

GDB (GNU Debugger — отладчик проекта GNU) работает на многих UNIX-подобных системах и умеет производить отладку многих языков программирования. GDB предлагает обширные средства для слежения и контроля за выполнением компьютерных программ.

Отладчик GDB позволяет:

-   начать выполнение программы, задав всё, что может повлиять на её поведение;
-   остановить программу при указанных условиях;
-   исследовать, что случилось, когда программа остановилась;
-   изменить программу так, чтобы можно было поэкспериментировать с устранением эффектов одной ошибки и продолжить выявление других.

## Понятие подпрограммы

Подпрограмма — это, как правило, функционально законченный участок кода, который можно многократно вызывать из разных мест программы. В отличие от простых переходов из подпрограмм существует возврат на команду, следующую за вызовом.

Для вызова подпрограммы используется инструкция `call`, которая заносит адрес следующей инструкции в стек и загружает в регистр `EIP` адрес соответствующей подпрограммы. Подпрограмма завершается инструкцией `ret`, которая извлекает из стека адрес возврата и заносит его в `EIP`.

# Выполнение лабораторной работы

## 9.4.1. Реализация подпрограмм в NASM

### Программа вычисления выражения \( f(x) = 2x + 7 \)

Исходный код программы (листинг 9.1):

```assembly
%include 'in_out.asm'

SECTION .data
    msg: DB 'Введите x: ',0
    result: DB '2x+7=',0

SECTION .bss
    x: RESB 80
    res: RESB 80

SECTION .text
GLOBAL _start
_start:

; ---
; Основная программа
; ---
    mov eax, msg
    call sprint

    mov eax, x      ; Адрес буфера для sread
    mov ebx, 80     ; Максимальная длина для sread
    call sread

    mov eax, x      ; Адрес строки для atoi
    call atoi

    call _calcul    ; Вызов подпрограммы _calcul

    mov eax,result
    call sprint
    mov eax,[res]
    call iprintLF

    call quit

; ---
; Подпрограмма вычисления
; выражения "2x+7"
; ---
_calcul:
    mov ebx,2
    mul ebx
    add eax,7
    mov [res],eax
    ret    ; выход из подпрограммы

```
Создание исполняемого файла и проверка его работы:

![Работа программы lab09-1](images/lab09-1-output.png){#fig-091 width=70%}

```bash
nasm -f elf lab09-1.asm
ld -m elf_i386 -o lab09-1 lab09-1.o in_out.o
./lab09-1
```
Программа запрашивает ввод значения x, вычисляет 2x+7 и выводит результат.

## Модификация программы с добавлением вложенной подпрограммы

Требуется изменить программу, добавив подпрограмму _subcalcul в подпрограмму _calcul, для вычисления выражения 

f(g(x)), где x
вводится с клавиатуры, f(x)=2x+7, g(x)=3x−1.

Исходный код модифицированной программы:

```
%include 'in_out.asm'

SECTION .data
    msg: DB 'Введите x: ',0
    result: DB 'f(g(x))=2*(3x-1)+7=',0

SECTION .bss
    x: RESB 80
    res: RESB 80

SECTION .text
GLOBAL _start
_start:

; ---
; Основная программа
; ---
    mov eax, msg
    call sprint

    mov eax, x
    mov ebx, 80
    call sread

    mov eax, x
    call atoi

    call _calcul    ; Вызов подпрограммы _calcul

    mov eax, result
    call sprint
    mov eax, [res]
    call iprintLF

    call quit

; ---
; Подпрограмма вычисления f(g(x)) = 2*(3x-1)+7
; Вход: eax = x (число)
; Выход: результат в [res]
; ---
_calcul:
    call _subcalcul
    mov ebx, 2
    mul ebx
    add eax, 7
    mov [res], eax
    ret

; ---
; Подпрограмма вычисления g(x) = 3x - 1
; Вход: eax = x (число)
; Выход: eax = 3x - 1
; ---
_subcalcul:
    mov ebx, 3
    mul ebx
    sub eax, 1
    ret
```
Сборка и тестирование программы:

![Вывод модифицированной программы](images/lab09-1b-output.png){#fig-091b width=70%}

```
nasm -f elf lab09-1b.asm
ld -m elf_i386 -o lab09-1b lab09-1b.o in_out.o![Исправленный вывод программы lab09-5](images/lab09-5-fixed.png){#fig-095-fixed width=70%}
./lab09-1b
```

## 9.4.2. Отладка программам с помощью GDB

### Программа вывода сообщения Hello world!

Исходный код программы (листинг 9.2):

```assembly
SECTION .data
    msg1:    db "Hello, ",0x0
    msg1Len:   equ $ - msg1

    msg2:    db "world!",0xa
    msg2Len:   equ $ - msg2

SECTION .text
    global _start

_start:
    mov eax, 4
    mov ebx, 1
    mov ecx, msg1
    mov edx, msg1Len
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, msg2
    mov edx, msg2Len
    int 0x80

    mov eax, 1
    mov ebx, 0
    int 0x80

```

Сборка с отладочной информацией:

```
nasm -f elf -g -l lab09-2.lst lab09-2.asm
ld -m elf_i386 -o lab09-2 lab09-2.o
```

## Запуск программы в GDB

Загружаем исполняемый файл в отладчик и запускаем программу:

```
gdb lab09-2
(gdb) run
```
Программа успешно выполняется и выводит "Hello, world!".

## Установка точек останова и дизассемблирование

Устанавливаем точку останова на метке _start:

```
(gdb) break _start
Breakpoint 1 at 0x8049000: file lab09-2.asm, line 12.
```
Запускаем программу, она останавливается на точке останова:

```
(gdb) run
Starting program: ~/work/arch-pc/lab09/lab09-2
Breakpoint 1, _start () at lab09-2.asm:12
12    mov eax, 4
```
Просматриваем дизассемблированный код в синтаксисе ATT (по умолчанию):

```
(gdb) disassemble _start
```

Переключаемся на синтаксис Intel:

```
(gdb) set disassembly-flavor intel
(gdb) disassemble _start
```

Переключаемся на синтаксис Intel:

```
(gdb) set disassembly-flavor intel
(gdb) disassemble _start
```

Различия: в синтаксисе Intel порядок операндов dest, src, в ATT — src, dest; также различаются префиксы и обозначения регистров.

Включаем режим псевдографики (TUI) для удобного просмотра регистров и кода:

```
(gdb) layout asm
(gdb) layout regs
```

Получаем окна с регистрами, дизассемблированным кодом и командной строкой (рис. 9.2).

![Режим TUI в GDB](images/gdb-tui.png){#fig-gdb-tui width=70%}

# Добавление точек останова по адресу инструкции

Устанавливаем вторую точку останова по адресу предпоследней инструкции mov ebx, 0x0. Адрес определяем из дизассемблированного листинга (например, 0x8049031):

```
(gdb) break *0x8049031
Breakpoint 2 at 0x8049031: file lab09-2.asm, line 25.
```

Проверяем список точек останова:

![Список точек останова в GDB](images/gdb-breakpoints.png){#fig-gdb-breakpoints width=70%}


```
(gdb) info breakpoints
```
# Работа с данными программы в GDB

Выполняем 5 инструкций с помощью stepi и наблюдаем за изменением регистров. После каждого шага значения регистров eax, ebx, ecx, edx, eip изменяются в соответствии с выполняемыми инструкциями.

Просмотр содержимого памяти:

![Просмотр памяти в GDB](images/gdb-memory.png){#fig-gdb-memory width=70%}

```
(gdb) x/1sb &msg1
0x804a000 <msg1>: "Hello, "
(gdb) x/1sb 0x804a008
0x804a008 <msg2>: "world!\n"
```

Изменение памяти с помощью команды set:

![Изменение памяти в GDB](images/gdb-modify-memory.png){#fig-gdb-modify-memory width=70%}

```
(gdb) set {char}&msg1='h'
(gdb) x/1sb &msg1
0x804a000 <msg1>: "hello, "
(gdb) set {char}0x804a008='W'
(gdb) x/1sb 0x804a008
0x804a008 <msg2>: "World!\n"
```

Работа с регистрами. Вывод значения регистра edx в различных форматах:

![Работа с регистрами в GDB](images/gdb-registers.png){#fig-gdb-registers width=70%}

```
(gdb) p/x $edx   # шестнадцатеричный
(gdb) p/t $edx   # двоичный
(gdb) p/s $edx   # символьный (интерпретация как ASCII)
```

Изменение значения регистра ebx:

```
(gdb) set $ebx=2
(gdb) p/s $ebx   # вывод как число
(gdb) set $ebx='2'
(gdb) p/s $ebx   # вывод как ASCII-код символа '2' (50)
```

После завершения отладки выходим из GDB:

```
(gdb) quit
```

## Обработка аргументов командной строки в GDB

Копируем программу из лабораторной работы №8 (вывод аргументов командной строки) в файл lab09-3.asm. Собираем её с отладочной информацией.

Загружаем в GDB с аргументами:

```
gdb --args lab09-3 аргумент1 аргумент 2 'аргумент 3'
```
Устанавливаем точку останова на _start и запускаем программу:

```
(gdb) break _start
(gdb) run
```

Исследуем расположение аргументов в стеке. По адресу $esp находится количество аргументов (включая имя программы):

```
(gdb) x/x $esp
0xffffd200: 0x05
```

Далее, начиная с $esp+4, располагаются указатели на строки аргументов:

```
(gdb) x/s *(void**)($esp + 4)   # имя программы
0xffffd358: "~/lab09-3"
(gdb) x/s *(void**)($esp + 8)   # первый аргумент
0xffffd3bc: "аргумент1"
(gdb) x/s *(void**)($esp + 12)  # второй аргумент
0xffffd3ce: "аргумент"
(gdb) x/s *(void**)($esp + 16)  # третий аргумент
0xffffd3df: "2"
(gdb) x/s *(void**)($esp + 20)  # четвёртый аргумент
0xffffd3e1: "аргумент 3"
```

Шаг изменения адреса равен 4 байтам, потому что в 32-битной архитектуре размер указателя — 4 байта.

![Аргументы командной строки в стеке](images/gdb-stack-args.png){#fig-gdb-stack-args width=70%}

# Самостоятельная работа

## Задание 1. Преобразование программы с использованием подпрограммы

Требуется преобразовать программу из лабораторной работы №8 (Задание №1 для самостоятельной работы), реализовав вычисление значения функции \( f(x) \) как подпрограмму.

В качестве примера взята функция $$ f(x) = (x + 1) * 2 $$. Исходный код программы:

```assembly
%include 'in_out.asm'

SECTION .data
    msg: DB 'Введите x: ',0
    result: DB 'f(x)=(x+1)*2=',0

SECTION .bss
    x: RESB 80
    res: RESB 80

SECTION .text
GLOBAL _start
_start:

    mov eax, msg
    call sprint

    mov eax, x
    mov ebx, 80
    call sread

    mov eax, x
    call atoi

    call calc_f    ; Вызов подпрограммы calc_f

    mov eax, result
    call sprint
    mov eax, [res]
    call iprintLF

    call quit

; ---
; Подпрограмма вычисления f(x) = (x + 1) * 2
; Вход:  eax = x (число)
; Выход: результат в [res]
; ---
calc_f:
    inc eax        ; eax = x + 1
    mov ebx, 2
    mul ebx        ; eax = (x + 1) * 2
    mov [res], eax
    ret
```
Сборка и тестирование:

![Работа программы lab09-4](images/lab09-4-output.png){#fig-094 width=70%}

```
nasm -f elf lab09-4.asm
ld -m elf_i386 -o lab09-4 lab09-4.o in_out.o
./lab09-4
```

При вводе, например, числа 5, программа выводит f(x)=(x+1)*2=12, что соответствует (5+1)*2=12.

## Задание 2. Поиск и исправление ошибки с помощью GDB

Дана программа вычисления выражения (3+2)∗4+5 (листинг 9.3), которая даёт неверный результат.

Исходный код ошибочной программы:

```
%include 'in_out.asm'

SECTION .data
div: DB 'Результат: ',0

SECTION .text
GLOBAL _start
_start:

; --- Вычисление выражения (3+2)*4+5
    mov ebx,3
    mov eax,2
    add ebx,eax
    mov ecx,4
    mul ecx
    add ebx,5
    mov edi,ebx

; --- Вывод результата на экран
mov  eax,div
call sprint
mov  eax,edi
call iprintLF

call quit
```

При запуске программа выводит Результат: 10, хотя правильный результат равен 25.

![Ошибочный вывод программы lab09-5](images/lab09-5-error.png){#fig-095-error width=70%}

# Анализ в GDB

Загружаем программу в GDB, устанавливаем точку останова на _start и выполняем пошагово:

```
(gdb) break _start
(gdb) run
(gdb) stepi
...

После выполнения инструкций:

mov ebx,3 → ebx=3

mov eax,2 → eax=2

add ebx,eax → ebx=5 (верно)

mov ecx,4 → ecx=4

mul ecx → eax = eax * ecx = 2 * 4 = 8 (ошибка: нужно умножать ebx, а не eax)

add ebx,5 → ebx = 5 + 5 = 10

mov edi,ebx → edi=10

Таким образом, ошибка заключается в том, что умножение выполняется над регистром eax, который содержит 2, а не над ebx, который содержит сумму 3+2.

![Анализ ошибки в GDB](images/gdb-debug-error.png){#fig-gdb-debug-error width=70%}

# Исправленная программа

Перед умножением необходимо переместить сумму из ebx в eax:

```
; --- Вычисление выражения (3+2)*4+5
    mov ebx,3
    mov eax,2
    add ebx,eax      ; ebx = 5
    mov eax, ebx     ; перемещаем сумму в eax для умножения
    mov ecx,4
    mul ecx          ; eax = 5 * 4 = 20
    add eax,5        ; eax = 20 + 5 = 25
    mov edi, eax     ; сохраняем результат в edi
```

После исправления программа выводит Результат: 25, что является верным ответом.

![Исправленный вывод программы lab09-5](images/lab09-5-fixed.png){#fig-095-fixed width=70%}

# Выводы

В ходе выполнения лабораторной работы были достигнуты следующие результаты:

1.  Приобретены навыки написания программ на ассемблере NASM с использованием подпрограмм. Реализованы программы с простой и вложенной подпрограммами, что позволило лучше понять механизм вызова и возврата из подпрограмм (инструкции `call` и `ret`), а также организацию передачи параметров через регистры.

2.  Освоены основные методы отладки с помощью GDB. Изучены команды установки точек останова (`break`), пошагового выполнения (`stepi`, `nexti`), просмотра и изменения регистров и памяти (`info registers`, `x`, `set`, `print`). Получен опыт работы в TUI-режиме GDB для одновременного наблюдения за регистрами и дизассемблированным кодом.

3.  Исследовано расположение аргументов командной строки в стеке процесса с помощью GDB, подтверждено, что в 32-битной архитектуре указатели на аргументы располагаются с шагом 4 байта.

4.  Выполнены задания для самостоятельной работы:
    -   Преобразована программа из предыдущей лабораторной работы, вынесено вычисление функции в отдельную подпрограмму.
    -   С помощью отладчика GDB обнаружена и исправлена логическая ошибка в программе вычисления арифметического выражения.

Таким образом, цель работы — приобретение навыков написания программ с использованием подпрограмм и знакомство с методами отладки при помощи GDB — достигнута.

# Список литературы{.unnumbered}

1. GDB: The GNU Project Debugger. — URL: https://www.gnu.org/software/gdb/.
2. GNU Bash Manual. — 2016. — URL: https://www.gnu.org/software/bash/manual/.
3. Midnight Commander Development Center. — 2021. — URL: https://midnight-commander.org/.
4. NASM Assembly Language Tutorials. — 2021. — URL: https://asmtutor.com/.
5. Newham C. Learning the bash Shell: Unix Shell Programming. — O’Reilly Media, 2005. — 354 c. — (In a Nutshell). — ISBN 0596009658.
6. Robbins A. Bash Pocket Reference. — O’Reilly Media, 2016. — 156 c. — ISBN 978-1491941591.
7. The NASM documentation. — 2021. — URL: https://www.nasm.us/docs.php.
8. Zarrelli G. Mastering Bash. — Packt Publishing, 2017. — 502 c. — ISBN 9781784396879.
9. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018.
10. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон-Пресс, 2017.
11. Новожилов О. П. Архитектура ЭВМ и систем. — М. : Юрайт, 2016.
12. Расширенный ассемблер: NASM. — 2021. — URL: https://www.opennet.ru/docs/RUS/nasm/.
13. Робачевский А., Немнюгин С., Стесик О. Операционная система UNIX. — 2-е изд. — БХВ-Петербург, 2010. — 656 с. — ISBN 978-5-94157-538-1.
14. Столяров А. Программирование на языке ассемблера NASM для OC Unix. — 2-е изд. — М. : MAKC Пресс, 2011.
15. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с.
16. Таненбаум Э., Бос Х. Современные операционные системы. — 4-е изд. — СПб. : Питер, 2015. — 1120 с.

::: {#refs}
:::

