---
## Author
author:
  name: Кебеде Берекет Дагне, НПИбд-01-25
  email: 1032255864@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Отчет по лабораторной работе №6"
subtitle: "Арифметические операции в NASM"
license: "CC BY"

format:
  pdf:
    documentclass: article
    mainfont: "DejaVu Serif"
    lang: ru
    geometry: [left=2cm, right=2cm, top=2cm, bottom=2cm]
  docx: default
toc: true
number-sections: true
---

# Цель работы

Освоение арифметических инструкций языка ассемблера NASM.


# Задание

1.  Изучить арифметические инструкции языка ассемблера NASM.
2.  Выполнить сложение символов и чисел, проанализировать результаты.
3.  Использовать подпрограммы из файла `in_out.asm` для преобразования и вывода чисел (`iprint`, `iprintLF`, `atoi`).
4.  Написать и выполнить программу вычисления арифметического выражения.
5.  Написать программу вычисления варианта задания по номеру студенческого билета.
6.  Ответить на контрольные вопросы.
7.  Выполнить самостоятельную работу: написать программу вычисления заданной функции \( f(x) \) согласно полученному варианту.

# Теоретическое введение

Язык ассемблера NASM предоставляет набор арифметических инструкций для работы с целыми числами. Основные способы адресации операндов:
- **Регистровая адресация**: операнды находятся в регистрах (например, `mov ax, bx`).
- **Непосредственная адресация**: значение операнда задано в команде (например, `mov ax, 2`).
- **Адресация памяти**: операнд задаёт адрес в памяти (например, `mov eax, [intg]`).

Основные арифметические инструкции:
- **`add`**: сложение двух операндов, результат помещается в первый операнд.
- **`sub`**: вычитание второго операнда из первого, результат помещается в первый операнд.
- **`inc`/`dec`**: увеличение/уменьшение операнда на 1.
- **`neg`**: изменение знака операнда (дополнение до двух).
- **`mul`/`imul`**: беззнаковое и знаковое умножение. Один множитель задаётся явно, второй берётся из регистра `AL/AX/EAX`. Результат помещается в `AX`, `DX:AX` или `EDX:EAX` в зависимости от размера операнда.
- **`div`/`idiv`**: беззнаковое и знаковое деление. Делитель задаётся явно, делимое берётся из `AX`, `DX:AX` или `EDX:EAX`. Результат: частное в `AL/AX/EAX`, остаток в `AH/DX/EDX`.

При вводе-выводе информация представляется в символьном виде (коды ASCII). Для преобразования между символьным представлением и числами используются подпрограммы из файла `in_out.asm`:
- `iprint` – вывод числа в формате ASCII (значение в `eax`).
- `iprintLF` – то же, что `iprint`, но добавляет символ перевода строки.
- `atoi` – преобразует строку ASCII в целое число (адрес строки в `eax`, результат в `eax`).

# Выполнение лабораторной работы

## Символьные и численные данные в NASM

### 1. Создание каталога и файла lab6-1.asm
Был создан каталог для работы и файл `lab6-1.asm`:

![Создание каталога и копирование файла in_out.asm](image/fig01_setup.png){#fig-01 width=80%}

### 2. Программа вывода значения регистра eax (листинг 6.1)
В файл `lab6-1.asm` был помещён код из листинга 6.1. В этой программе в регистры `eax` и `ebx` помещаются ASCII-коды символов '6' и '4', выполняется их сложение (`add`), и результат выводится с помощью `sprintLF`. 

Программа была откомпилирована и запущена:

В результате работы программы на экран был выведен символ `J` (рис. 2). Это соответствует ожиданиям, так как код символа '6' — 54, код символа '4' — 52, их сумма равна 106, что является ASCII-кодом символа 'j' (строчная латинская 'j'). В данном случае вывелась заглавная 'J', что может зависеть от настроек терминала.

![Вывод программы lab6-1 (символы '6' и '4')](image/fig02_lab6-1_chars.png){#fig-02 width=80%}

### 3. Модификация программы: использование чисел вместо символов
В программе `lab6-1.asm` инструкции `mov eax,'6'` и `mov ebx,'4'` были заменены на `mov eax,6` и `mov ebx,4`. После перекомпиляции и запуска программа не вывела видимого символа (рис. 3). Это объясняется тем, что сумма 6+4=10, а код 10 в таблице ASCII соответствует управляющему символу LF (Line Feed), который переводит строку, но не отображается как печатный символ.

![Вывод программы lab6-1 (числа 6 и 4)](image/fig03_lab6-1_numbers.png){#fig-03 width=80%}

### 4. Использование подпрограммы iprintLF
Был создан файл `lab6-2.asm` с кодом из листинга 6.2. В этой программе для вывода результата используется подпрограмма `iprintLF` из файла `in_out.asm`. В регистры помещаются коды символов '6' и '4', выполняется сложение, и результат выводится как число.

После компиляции и запуска программа вывела число `106` рис. 4, что подтверждает правильность работы `iprintLF`: она интерпретирует значение в регистре `eax` как целое число, а не как ASCII-код символа.

![Вывод программы lab6-2 с iprintLF (символы)](image/fig04_lab6-2_iprintlf_chars.png){#fig-04 width=80%}

### 5. Сравнение iprintLF и iprint
Программа `lab6-2.asm` была модифицирована: вместо кодов символов в регистры были помещены числа 6 и 4. При использовании `iprintLF` программа вывела число `10` с переводом строки (рис. 5).

![Вывод программы lab6-2 с iprintLF (числа)](image/fig05_lab6-2_iprintlf_numbers.png){#fig-05 width=80%}

Затем функция `iprintLF` была заменена на `iprint`. После перекомпиляции программа вывела число `10` без перевода строки, и приглашение командной оболочки появилось сразу после результата рис. 6.

![Вывод программы lab6-2 с iprint (числа)](image/fig06_lab6-2_iprint_numbers.png){#fig-06 width=80%}

 Это наглядно демонстрирует различие между функциями: `iprint` выводит только число, `iprintLF` добавляет символ новой строки.

## Выполнение арифметических операций в NASM

### 6. Программа вычисления выражения \( f(x) = (5 \times 2 + 3)/3 \)
Был создан файл `lab6-3.asm` с кодом из листинга 6.3. Программа последовательно выполняет умножение, сложение и деление, используя инструкции `mul`, `add` и `div`. Результат и остаток от деления выводятся на экран с поясняющими сообщениями.

Запуск программы показал корректный результат: `Результат: 4`, `Остаток от деления: 1` (рис. 7).

![Вывод программы lab6-3 (выражение 1)](image/fig07_lab6-3_expr1.png){#fig-07 width=80%}

### 7. Модификация программы для выражения \( f(x) = (4 \times 6 + 2)/5 \)

В программе были изменены константы: `mov eax,5` на `mov eax,4`, `mov ebx,2` на `mov ebx,6`, `add eax,3` на `add eax,2` и `mov ebx,3` на `mov ebx,5`. После перекомпиляции программа выдала результат `5` и остаток `1` (рис. 8), что соответствует вычислениям: \( (4 \times 6 + 2) = 26 \), \( 26 / 5 = 5 \) (остаток 1).

![Вывод программы lab6-3 (выражение 2)](image/fig08_lab6-3_expr2.png){#fig-08 width=80%}

### 8. Программа вычисления варианта задания

Был создан файл `variant.asm` с кодом из листинга 6.4. Программа запрашивает ввод номера студенческого билета, преобразует введённую строку в число с помощью `atoi`, вычисляет вариант по формуле (S_n mod 20) + 1 и выводит результат.

При вводе номера `1032255864` программа рассчитала вариант `5` (рис. 9).

![Работа программы variant.asm](image/fig09_variant.png){#fig-09 width=80%}

Аналитическая проверка: 1032255864 mod 20 = 4, 4 + 1 = 5, что подтверждает правильность работы программы.

![Вывод программы lab6-1 (символы '6' и '4')](image/fig02_lab6-1_chars.png){#fig-02 width=80%}

**Ответы на контрольные вопросы по листингу 6.4:**
1.  Вывод сообщения «Ваш вариант:» выполняют строки:
    ```
    mov eax,rem
    call sprint
    ```
2.  Инструкции
    ```
    mov ecx, x
    mov edx, 80
    call sread
    ```
    предназначены для чтения строки из стандартного ввода: `ecx` получает адрес буфера `x`, `edx` — максимальную длину, `sread` читает ввод.
3.  Инструкция `call atoi` вызывает подпрограмму преобразования ASCII-строки (адрес в `eax`) в целое число (результат в `eax`).
4.  Вычисления варианта выполняют строки:
    ```
    xor edx,edx
    mov ebx,20
    div ebx
    inc edx
    ```
5.  Остаток от деления при выполнении `div ebx` записывается в регистр `edx`.
6.  Инструкция `inc edx` увеличивает остаток на 1, так как варианты нумеруются с 1, а не с 0.
7.  Вывод результата вычислений выполняют строки:
    ```
    mov eax,edx
    call iprintLF
    ```

# Задание для самостоятельной работы

## 1. Программа вычисления функции \( f(x) \)
Согласно результату выполнения программы `variant.asm`, мой вариант для самостоятельной работы — **5**. Следовательно, необходимо написать программу вычисления выражения:
\[
f(x) = (9x - 8)/8
\]
с проверкой для значений \( x_1 = 8 \) и \( x_2 = 64 \).

Программа должна:
1.  Выводить выражение для вычисления.
2.  Запрашивать ввод значения \( x \).
3.  Вычислять значение выражения по заданной формуле.
4.  Выводить результат.

**Примечание:** При выполнении деления используется только целая часть частного (остаток игнорируется).

### Текст программы
Был создан файл `lab6-ind.asm` со следующим кодом:

```asm
; ---
; Программа вычисления функции f(x) = (9x - 8)/8
; Вариант 5
; ---

%include 'in_out.asm'

SECTION .data
msg1: DB 'Выражение: f(x) = (9x - 8)/8',0
msg2: DB 'Введите значение x: ',0
msg3: DB 'Результат: ',0

SECTION .bss
x: RESB 80

SECTION .text
GLOBAL _start
_start:

mov eax, msg1
call sprintLF

mov eax, msg2
call sprint

mov ecx, x
mov edx, 80
call sread

mov eax, x
call atoi        ; преобразуем введённую строку в число (x в eax)

; Вычисление (9x - 8)/8
mov ebx, 9
mul ebx          ; eax = 9*x
sub eax, 8       ; eax = 9x - 8

xor edx, edx     ; обнуляем edx для деления
mov ebx, 8
div ebx          ; eax = (9x - 8) / 8, edx = остаток

mov edi, eax     ; сохраняем результат в edi

mov eax, msg3
call sprint
mov eax, edi
call iprintLF

call quit
```

### Компиляция и запуск
Программа была откомпилирована и запущена для значений \( x_1 = 8 \) и \( x_2 = 64 \).

**Результат для \( x_1 = 8 \):**
\( (9 \times 8 - 8)/8 = (72 - 8)/8 = 64/8 = 8 \). Программа вывела `8` (рис. 10).

![Работа программы для x=8](image/fig10_indep_x8.png){#fig-10 width=80%}

**Результат для \( x_2 = 64 \):**
\( (9 \times 64 - 8)/8 = (576 - 8)/8 = 568/8 = 71 \). Программа вывела `71` (рис. 11).

![Работа программы для x=64](image/fig11_indep_x64.png){#fig-11 width=80%}

Программа работает корректно, результаты совпадают с аналитическими вычислениями.


# Выводы

В ходе выполнения лабораторной работы были успешно освоены арифметические инструкции языка ассемблера NASM (`add`, `sub`, `mul`, `div`, `inc`). На практике исследована разница между работой с символьными данными (ASCII-кодами) и числовыми значениями. Применены подпрограммы из файла `in_out.asm` для корректного ввода-вывода чисел (`iprint`, `iprintLF`, `atoi`). Были написаны и отлажены программы, выполняющие арифметические выражения и вычисляющие вариант задания по номеру студенческого билета. Цель работы — освоение арифметических инструкций NASM — достигнута.

# Список литературы{.unnumbered}

1. GDB: The GNU Project Debugger. — URL: https://www.gnu.org/software/gdb/.
2. GNU Bash Manual. — 2016. — URL: https://www.gnu.org/software/bash/manual/.
3. Midnight Commander Development Center. — 2021. — URL: https://midnight-commander.org/.
4. NASM Assembly Language Tutorials. — 2021. — URL: https://asmtutor.com/.
5. Newham C. Learning the bash Shell: Unix Shell Programming. — O’Reilly Media, 2005. — 354 c. — (In a Nutshell). — ISBN 0596009658.
6. Robbins A. Bash Pocket Reference. — O’Reilly Media, 2016. — 156 c. — ISBN 978-1491941591.
7. The NASM documentation. — 2021. — URL: https://www.nasm.us/docs.php.
8. Zarrelli G. Mastering Bash. — Packt Publishing, 2017. — 502 c. — ISBN 9781784396879.
9. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018.
10. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон-Пресс, 2017.
11. Новожилов О. П. Архитектура ЭВМ и систем. — М. : Юрайт, 2016.
12. Расширенный ассемблер: NASM. — 2021. — URL: https://www.opennet.ru/docs/RUS/nasm/.
13. Робачевский А., Немнюгин С., Стесик О. Операционная система UNIX. — 2-е изд. — БХВ-Петербург, 2010. — 656 с. — ISBN 978-5-94157-538-1.
14. Столяров А. Программирование на языке ассемблера NASM для OC Unix. — 2-е изд. — М. : MAKC Пресс, 2011.
15. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с.
16. Таненбаум Э., Бос Х. Современные операционные системы. — 4-е изд. — СПб. : Питер, 2015. — 1120 с.

::: {#refs}
:::
