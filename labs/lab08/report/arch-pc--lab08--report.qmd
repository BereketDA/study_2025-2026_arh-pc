---
## Author
author:
  name: Кебеде Берекет Дагне, НПИбд-01-25
  email: 1032255864@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Архитектура ЭВМ"
subtitle: "Лабораторная работа №8. Программирование цикла. Обработка аргументов командной строки."
license: "CC BY"

format:
  pdf:
    documentclass: article
    mainfont: "DejaVu Serif"
    lang: ru
    geometry: [left=2cm, right=2cm, top=2cm, bottom=2cm]
  docx: default
toc: true
number-sections: true
---

# Цель работы

Приобретение навыков написания программ с использованием циклов и обработкой аргументов командной строки.

# Задание

1. Изучить организацию стека и основные операции работы с ним (push, pop).
2. Изучить инструкцию организации циклов `loop`.
3. Написать программу вывода значений регистра `ecx` с использованием цикла `loop`.
4. Исследовать влияние изменения регистра `ecx` внутри тела цикла на корректность работы программы.
5. Использовать стек для сохранения значения счетчика цикла.
6. Написать программу обработки аргументов командной строки (вывод аргументов, вычисление суммы и произведения).
7. Выполнить задание для самостоятельной работы: написать программу, вычисляющую сумму значений функции \( f(x) \) для заданных аргументов командной строки.

# Теоретическое введение

## Организация стека

Стек — это структура данных, организованная по принципу LIFO («Last In — First Out» или «последним пришёл — первым ушёл»). Стек является частью архитектуры процессора и реализован на аппаратном уровне. Для работы со стеком в процессоре есть специальные регистры (ss, bp, sp) и команды.

Основной функцией стека является функция сохранения адресов возврата и передачи аргументов при вызове процедур. Кроме того, в нём выделяется память для локальных переменных и могут временно храниться значения регистров.

Стек имеет вершину, адрес последнего добавленного элемента, который хранится в регистре esp (указатель стека). Противоположный конец стека называется дном. Значение, помещённое в стек последним, извлекается первым. При помещении значения в стек указатель стека уменьшается, а при извлечении — увеличивается.

Для стека существует две основные операции:
- добавление элемента в вершину стека (push);
- извлечение элемента из вершины стека (pop).

## Инструкции организации циклов

Для организации циклов существуют специальные инструкции. Для всех инструкций максимальное количество проходов задаётся в регистре `ecx`. Наиболее простой является инструкция `loop`. Она позволяет организовать безусловный цикл, типичная структура которого имеет следующий вид:

```
mov ecx, 100 ; Количество проходов
NextStep:
... ; тело цикла
loop NextStep ; Повторить 'ecx' раз от метки NextStep
```

Инструкция `loop` выполняется в два этапа. Сначала из регистра `ecx` вычитается единица и его значение сравнивается с нулём. Если регистр не равен нулю, то выполняется переход к указанной метке. Иначе переход не выполняется и управление передаётся команде, которая следует сразу после команды `loop`.

## Обработка аргументов командной строки

При запуске программы в NASM аргументы командной строки загружаются в стек в обратном порядке, кроме того в стек записывается имя программы и общее количество аргументов. Последние два элемента стека для программы, скомпилированной NASM, – это всегда имя программы и количество переданных аргументов.

Таким образом, для того чтобы использовать аргументы в программе, их просто нужно извлечь из стека. Обработку аргументов нужно проводить в цикле. Т.е. сначала нужно извлечь из стека количество аргументов, а затем циклично для каждого аргумента выполнить логику программы.

# Выполнение лабораторной работы

## Реализация циклов в NASM

В соответствии с заданием был создан каталог для программ лабораторной работы №8 и файл `lab8-1.asm`:

```bash
mkdir -p ~/work/arch-pc/lab08
cd ~/work/arch-pc/lab08
touch lab8-1.asm
```

В файл lab8-1.asm был помещён код из листинга 8.1 (программа вывода значений регистра ecx):


```
; ---
; Программа вывода значений регистра 'ecx'
; ---

%include 'in_out.asm'

SECTION .data
msg1 db 'Введите N: ',0h

SECTION .bss
N:    resb 10

SECTION .text
    global _start
_start:

; ---   Вывод сообщения 'Введите N: '
    mov  eax,msg1
    call sprint

; ---   Ввод 'N'
    mov  eax, N
    mov  ebx, 10
    call sread

; ---   Преобразование 'N' из символа в число
    mov eax,N
    call atoi
    mov [N],eax

; ---   Организация цикла
    mov ecx,[N]    ; Счетчик цикла, `ecx=N`
label:
    mov [N],ecx
    mov eax,[N]
    call iprintLF ; Вывод значения `N`
    loop label    ; `ecx=ecx-1` и если `ecx` не '0'
    ; переход на `label`
    call quit
```
Программа была скомпилирована и запущена:
```
nasm -f elf lab8-1.asm -o lab8-1.o
ld -m elf_i386 lab8-1.o -o lab8-1
./lab8-1
```
После ввода числа 5 программа вывела значения от 5 до 1 (рис. @fig:lab8-1-orig).

![Вывод программы lab8-1 (оригинальная версия)](image/lab8-1-orig.png){#fig:lab8-1-orig width=80%}

## Изменение значения регистра `ecx` в теле цикла

Согласно заданию, в текст программы была добавлена инструкция `sub ecx,1` внутри тела цикла для изменения значения регистра `ecx`:

```asm
label:
    sub ecx,1    ; `ecx=ecx-1`
    mov [N],ecx
    mov eax,[N]
    call iprintLF
    loop label
```
После компиляции и запуска программы с вводом 5 было получено некорректное поведение: значения выводились с шагом -2, а затем после достижения нуля продолжили выводиться большие беззнаковые числа (рис. @fig:lab8-1-bug). Это произошло из-за того, что регистр ecx уменьшается дважды за итерацию: сначала явно инструкцией sub ecx,1, а затем неявно инструкцией loop. В результате счетчик цикла изменяется не на единицу за проход, а на два, что нарушает логику работы и приводит к бесконечному циклу после прохождения нуля.

![Вывод программы lab8-1 с инструкцией sub ecx,1 (некорректная работа)](image/lab8-1-bug.png){#fig:lab8-1-bug width=80%}

## Использование стека для сохранения значения счетчика

Для корректной работы цикла при необходимости изменения регистра `ecx` внутри его тела рекомендуется сохранять исходное значение счетчика в стеке перед модификацией и восстанавливать его после. В программу были добавлены инструкции `push ecx` и `pop ecx`:

```asm
label:
    push ecx    ; добавление значения ecx в стек
    sub ecx,1
    mov [N],ecx
    mov eax,[N]
    call iprintLF
    pop ecx    ; извлечение значения ecx из стека
    loop label
```
После компиляции и запуска программы с вводом 5 программа вывела значения от 4 до 0 (рис. @fig:lab8-1-fixed). Количество итераций цикла стало соответствовать введенному числу N=5, хотя выводимые значения смещены на единицу из-за вычитания перед печатью. Это демонстрирует, что использование стека позволяет сохранить значение счетчика цикла и обеспечить корректное количество проходов.

![Вывод программы lab8-1 с использованием стека (исправленная версия)](image/lab8-1-fixed.png){#fig:lab8-1-fixed width=80%}

## Обработка аргументов командной строки

### Программа вывода аргументов командной строки

Был создан файл `lab8-2.asm` с кодом из листинга 8.2 (программа вывода аргументов командной строки):

```asm
; ---
; Обработка аргументов командной строки
; ---

%include 'in_out.asm'

SECTION .text
global _start

_start:
    pop ecx         ; Извлекаем из стека в `ecx` количество аргументов
    pop edx         ; Извлекаем из стека в `edx` имя программы
    sub ecx, 1      ; Уменьшаем `ecx` на 1 (количество аргументов без названия программы)

next:
    cmp ecx, 0      ; проверяем, есть ли еще аргументы
    jz _end         ; если аргументов нет, выходим из цикла
    pop eax         ; иначе извлекаем аргумент из стека
    call sprintLF   ; вызываем функцию печати
    loop next       ; переход к обработке следующего аргумента

_end:
    call quit
```
Программа была скомпилирована и запущена с несколькими аргументами:

```
nasm -f elf lab8-2.asm -o lab8-2.o
ld -m elf_i386 lab8-2.o -o lab8-2
./lab8-2 аргумент1 аргумент 2 'аргумент 3'
```
Программа успешно вывела все три переданных аргумента (рис. @fig:lab8-2). Обработано было ровно столько аргументов, сколько было передано (без учета имени программы).

![Вывод программы lab8-2 (обработка аргументов командной строки)](image/lab8-2.png){#fig:lab8-2 width=80%}

## Программа вычисления суммы аргументов
Был создан файл lab8-3.asm с кодом из листинга 8.3 (программа вычисления суммы аргументов командной строки):

```
; ---
; Программа вычисления суммы аргументов командной строки
; ---

%include 'in_out.asm'

SECTION .data
msg db "Результат: ",0

SECTION .text
global _start

_start:
    pop ecx         ; Извлекаем из стека в `ecx` количество аргументов
    pop edx         ; Извлекаем из стека в `edx` имя программы
    sub ecx,1       ; Уменьшаем `ecx` на 1 (количество аргументов без названия программы)
    mov esi, 0      ; Используем `esi` для хранения промежуточных сумм

next:
    cmp ecx,0h      ; проверяем, есть ли еще аргументы
    jz _end         ; если аргументов нет, выходим из цикла
    pop eax         ; иначе извлекаем следующий аргумент из стека
    call atoi       ; преобразуем символ в число
    add esi,eax     ; добавляем к промежуточной сумме след. аргумент `esi=esi+eax`
    loop next       ; переход к обработке следующего аргумента

_end:
    mov eax, msg    ; вывод сообщения "Результат: "
    call sprint
    mov eax, esi    ; записываем сумму в регистр `eax`
    call iprintLF   ; печать результата
    call quit       ; завершение программы
```
Программа была скомпилирована и протестирована на наборе чисел:

```
./lab8-3 12 13 7 10 5
```
Программа корректно вычислила сумму 12+13+7+10+5 = 47 (рис. @fig:lab8-3).

![Вывод программы lab8-3 (вычисление суммы аргументов)](image/lab8-3.png){#fig:lab8-3 width=80%}

### Модификация программы для вычисления произведения

Текст программы из листинга 8.3 был изменён для вычисления произведения аргументов командной строки. Изменения включают инициализацию регистра `esi` значением 1 (нейтральный элемент для умножения) и использование инструкции `imul` вместо `add`. Полный код программы (`lab8-4.asm`):

```asm
; ---
; Программа вычисления произведения аргументов командной строки
; ---

%include 'in_out.asm'

SECTION .data
msg db "Результат: ",0

SECTION .text
global _start

_start:
    pop ecx         ; Извлекаем из стека в `ecx` количество аргументов
    pop edx         ; Извлекаем из стека в `edx` имя программы
    sub ecx,1       ; Уменьшаем `ecx` на 1 (количество аргументов без названия программы)
    mov esi, 1      ; Используем `esi` для хранения произведения (начальное значение 1)

next:
    cmp ecx,0h      ; проверяем, есть ли еще аргументы
    jz _end         ; если аргументов нет, выходим из цикла
    pop eax         ; иначе извлекаем следующий аргумент из стека
    call atoi       ; преобразуем символ в число
    imul esi, eax   ; умножаем промежуточное произведение на аргумент `esi = esi * eax`
    loop next       ; переход к обработке следующего аргумента

_end:
    mov eax, msg    ; вывод сообщения "Результат: "
    call sprint
    mov eax, esi    ; записываем произведение в регистр `eax`
    call iprintLF   ; печать результата
    call quit       ; завершение программы
```
Программа была скомпилирована и протестирована:

```
./lab8-4 2 3 4
```
Программа корректно вычислила произведение 2*3*4 = 24 (рис. @fig:lab8-4).

![Вывод программы lab8-4 (вычисление произведения аргументов)](image/lab8-4.png){#fig:lab8-4 width=80%}

## Задание для самостоятельной работы

В соответствии с вариантом 1 (функция \( f(x) = 2x + 15 \)) была написана программа `lab8-5.asm`, вычисляющая сумму значений функции \( f(x) \) для аргументов, переданных через командную строку. Программа выводит описание функции и полученный результат.

Код программы:

```asm
; ---
; Программа вычисления суммы f(x) = 2x + 15 для аргументов командной строки
; ---

%include 'in_out.asm'

SECTION .data
msg_func db "Функция: f(x)=2x+15",0h
msg_res  db "Результат: ",0

SECTION .text
global _start

_start:
    pop ecx            ; количество аргументов
    pop edx            ; имя программы
    sub ecx, 1         ; ecx = количество чисел x
    mov esi, 0         ; esi = накопитель суммы

next:
    cmp ecx, 0
    jz _end
    pop eax            ; аргумент (x как строка)
    call atoi          ; преобразуем в число в eax
    ; Вычисляем f(x) = 2x + 15
    mov ebx, eax       ; сохраняем x в ebx
    add eax, eax       ; eax = 2x
    add eax, 15        ; eax = 2x + 15
    add esi, eax       ; добавляем к сумме
    loop next

_end:
    ; Вывод сообщения о функции
    mov eax, msg_func
    call sprintLF
    ; Вывод результата
    mov eax, msg_res
    call sprint
    mov eax, esi
    call iprintLF
    call quit
```
Программа была скомпилирована и протестирована на наборе значений 

x=1,2,3,4:

```
./lab8-5 1 2 3 4
```
Результат работы программы (рис. @fig:lab8-5):

![Вывод программы lab8-5 (сумма значений функции)](image/lab8-5.png){#fig:lab8-5 width=80%}

$$ sum_{x=1}^{4} (2x + 15) = (2\cdot1+15) + (2\cdot2+15) + (2\cdot3+15) + (2\cdot4+15) = 17+19+21+23 = 80 $$

# Выводы

В ходе выполнения лабораторной работы были приобретены навыки написания программ на ассемблере NASM с использованием циклов и обработки аргументов командной строки.

Были выполнены следующие задачи:

1. Изучена организация стека и основные операции `push` и `pop`.
2. Освоена инструкция организации циклов `loop` и исследованы особенности её работы.
3. Написана программа, выводящая значения регистра `ecx` с помощью цикла `loop`. Показано, что изменение значения регистра `ecx` внутри тела цикла приводит к некорректному количеству итераций.
4. Продемонстрировано использование стека для сохранения значения счетчика цикла, что позволяет изменять регистр `ecx` внутри цикла без нарушения его логики.
5. Реализованы программы обработки аргументов командной строки: вывод аргументов, вычисление их суммы и произведения.
6. Выполнено задание для самостоятельной работы: написана программа, вычисляющая сумму значений линейной функции \( f(x) = 2x + 15 \) для аргументов, переданных через командную строку.

Таким образом, цель работы — приобретение навыков написания программ с использованием циклов и обработкой аргументов командной строки — достигнута.

# Список литературы{.unnumbered}

1. GDB: The GNU Project Debugger. — URL: https://www.gnu.org/software/gdb/.
2. GNU Bash Manual. — 2016. — URL: https://www.gnu.org/software/bash/manual/.
3. Midnight Commander Development Center. — 2021. — URL: https://midnight-commander.org/.
4. NASM Assembly Language Tutorials. — 2021. — URL: https://asmtutor.com/.
5. Newham C. Learning the bash Shell: Unix Shell Programming. — O’Reilly Media, 2005. — 354 c. — (In a Nutshell). — ISBN 0596009658.
6. Robbins A. Bash Pocket Reference. — O’Reilly Media, 2016. — 156 c. — ISBN 978-1491941591.
7. The NASM documentation. — 2021. — URL: https://www.nasm.us/docs.php.
8. Zarrelli G. Mastering Bash. — Packt Publishing, 2017. — 502 c. — ISBN 9781784396879.
9. Колдаев В. Д., Лупин С. А. Архитектура ЭВМ. — М. : Форум, 2018.
10. Куляс О. Л., Никитин К. А. Курс программирования на ASSEMBLER. — М. : Солон-Пресс, 2017.
11. Новожилов О. П. Архитектура ЭВМ и систем. — М. : Юрайт, 2016.
12. Расширенный ассемблер: NASM. — 2021. — URL: https://www.opennet.ru/docs/RUS/nasm/.
13. Робачевский А., Немнюгин С., Стесик О. Операционная система UNIX. — 2-е изд. — БХВ-Петербург, 2010. — 656 с. — ISBN 978-5-94157-538-1.
14. Столяров А. Программирование на языке ассемблера NASM для OC Unix. — 2-е изд. — М. : MAKC Пресс, 2011.
15. Таненбаум Э. Архитектура компьютера. — 6-е изд. — СПб. : Питер, 2013. — 874 с.
16. Таненбаум Э., Бос Х. Современные операционные системы. — 4-е изд. — СПб. : Питер, 2015. — 1120 с.

::: {#refs}
:::
